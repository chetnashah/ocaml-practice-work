
global let delcarations :
let abc = 1;

local let declaratiosn :
let abc = 1 in expr;

moral of story : all functions have single argument

ways to declare a function :

1) lambda way : function x -> x * x;
   lambda way with multi argument : "fun" keyword should be used
   lambda way also does pattern matching by the way
   
2) multi argument let (auto curried):
let fn a b c = a+b+c
which expands as
let fn = function a -> function b -> function c -> a + b + c

converting let's to lambdas :
let succ x = x + 1;
let succ = function x -> x + 1;

converting lambdas to lets:
let succ = function x -> x * x;;
let succ x = x * x;;

imp notes :
a function value ( a closure) can be passed around as a value or returned as a result in case of higher order functions.

higher order functions :
let h = function f -> function y -> (f y) + y;;
val h : (int -> int) -> int -> int = <fun> 

Why do functional languages don't need type annotation :
they are mostly analyzed by datum they are operating on
and all code is generic <T>

Type constraint :
programmer annotating the type helps compiler syntax is like following
let add (x:int) (y:int) = x + y;;

Pattern matching :
pattern matching applies on values(also function values - just like in lambda calculus)
lamdba style directly starts with pattern matching without letting us specify params , in match style we let specify param along with fn and also pattern match with same name( here v)

let imply v = match v with
| (true,x) -> x
| (false, x) -> true

Pattern matching should be linear, that is no variable can occur more than
once inside a pattern e.g.

(Wrong Syntax)
let equal cc = match cc with
| (x,x) -> true  // this a big NO NO
| (x,y) -> false;;
error : the variable is bound several times

Pattern matching with "function" keyword lets you pattern match on params:
function p1 -> expr1 | p2 -> expr2 |.... | pn -> exprn;

also equivalent to
function exp -> match exp with | p1 -> expr1 | p2 -> expr2 |....| pn -> exprn 

"new bindings/variable declarations happen in pattern matching"

Declaring new types :
type keyword is used
type name is always starts with lowercase letter
type constructor is always Uppercase letter followed by "of" followed by arguments
type constructor that does not need any argument is also known as a constant constructor
and can be directly treated as values

e.g.
type suit = Spades | Hearts | Diamonds | Clubs;; constant constructors
type card =
| King of suit
| Queen of suit
| Knave of suit
| Minor_card of suit * int
| Trump of int
| Joker;;

Type constructors are useful in pattern matching : people usually write an accompanying
tostring function for declared types like this

let string_of_suit = function
| Spades -> "spades"
| Hearts -> "hearts"
| Diamonds -> "diamonds"
| Clubs -> "clubs"


-------------------------------------- Expressions -----------------------------------

Sequence Control Structure : 
A sequence of expression is also an expression, with the evaluation value of the last
expr in sequence.

i.e.  expr1; expr2; expr3; expr4; ... exprn;

is also an expr with value of evaluation of exprn, and yes all expr are evaluated in order



Conditinal Control Structure :
if expr1 then expr2 else expr3 , evaluates to expr2 if expr1 is true, otherwise expr3


Parenthesized (grouping) expressions (for sequence control structure) :
One can group togethr multiple expression (like the sequence control structure) with value being last of all expressions
using two ways ===> parentheses/begin end
i.e.
     let expr =  ( expr1; expr2; expr3; expr4; ... exprn )
OR
     let expr = begin expr1; expr2; expr3; expr4; ... exprn end

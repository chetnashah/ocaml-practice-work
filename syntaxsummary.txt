
global let delcarations :
let abc = 1;

local let declaratiosn :
let abc = 1 in expr;

moral of story : all functions have single argument

ways to declare a function :

1) lambda way : function x -> x * x;
   lambda way with multi argument : "fun" keyword should be used
   lambda way also does pattern matching by the way
   
2) multi argument let (auto curried):
let fn a b c = a+b+c
which expands as
let fn = function a -> function b -> function c -> a + b + c

converting let's to lambdas :
let succ x = x + 1;
let succ = function x -> x + 1;

converting lambdas to lets:
let succ = function x -> x * x;;
let succ x = x * x;;

imp notes :
a function value ( a closure) can be passed around as a value or returned as a result in case of higher order functions.

higher order functions :
let h = function f -> function y -> (f y) + y;;
val h : (int -> int) -> int -> int = <fun> 

Why do functional languages don't need type annotation :
they are mostly analyzed by datum they are operating on
and all code is generic <T>

Type constraint :
programmer annotating the type helps compiler syntax is like following
let add (x:int) (y:int) = x + y;;

Pattern matching :
pattern matching applies on values(also function values - just like in lambda calculus)
lamdba style directly starts with pattern matching without letting us specify params , in match style we let specify param along with fn and also pattern match with same name( here v)

let imply v = match v with
| (true,x) -> x
| (false, x) -> true

Pattern matching should be linear, that is no variable can occur more than
once inside a pattern e.g.

(Wrong Syntax)
let equal cc = match cc with
| (x,x) -> true  // this a big NO NO
| (x,y) -> false;;
error : the variable is bound several times

Pattern matching with "function" keyword lets you pattern match on params:
function p1 -> expr1 | p2 -> expr2 |.... | pn -> exprn;

also equivalent to
function exp -> match exp with | p1 -> expr1 | p2 -> expr2 |....| pn -> exprn 

"new bindings/variable declarations happen in pattern matching"

Pattern matching can happen also without using match or function keywords,
simply using 'let' which does bindings of unbound vars in pattern side of let
binding
e.g. let (x,y) = 2,3;; // binds x to 2, and y to 3
let head :: 2 :: _ = [1;2;3];; // binds head to 1


----------  Types and pattern matchin -------------------------
product types : tuples(unnamed components) and records(named components)
Sum types: Variants(qualified unions and enum)

Declaring new types :
type keyword is used
type name is always starts with lowercase letter
type constructor is always Uppercase letter followed by "of" followed by arguments
type constructor that does not need any argument is also known as a constant constructor
and can be directly treated as values

tuple/record(named tuples) types(product types) :
(Note: field names should be lower case)
type personalName = {
     name: string;
     initial: string option;
     lastName: string;
}

variant(Sum) types:
e.g.
type suit = Spades | Hearts | Diamonds | Clubs;; constant constructors/enums
type card =
| King of suit
| Queen of suit
| Knave of suit
| Minor_card of suit * int
| Trump of int
| Joker;;

Type constructors are useful in pattern matching :
people usually write an accompanying
tostring function for declared types like this(like for java POJOs)


let string_of_suit = function
| Spades -> "spades"
| Hearts -> "hearts"
| Diamonds -> "diamonds"
| Clubs -> "clubs"

You will often see recursive variants used for defining recursive data types
like trees etc :
type binary_tree =
 | Leaf of int
 | Tree of binary_tree * binary_tree


Since sum types and product types are algebraic data types
you can arbitrarily combine them to make new types
e.g.
1) sum of product of type
type foo =
| Nothing
| Pair of int * int
| Info of String * String

2)sum of sum of types
type Meeting = Hello | Hi
type Parting = Bye | GoodBye

type Greeting = Meeting | Greeting

3) product of product of types
//t1 = string * string option  * string
type personalName = {
     firstName : string;
     middleInitial : string option;
     lastName : string;
}
// t2 = string option * string * string * string
type addressInfo = {
     address : string option;
     state : string;
     city : string;
     zip : string;
}
// t3 = t1 * t2
type contactInfo = {
     perosnalName : personalName;
     adress: addressInfo;
}

4) product of sum of types
type suit = Clubs | Diamonds | Hearts | Spade
type face = One | Two | Three | ... | Jack | Queen | King | Ace
type cardPlayed = {
     suit: suit;
     face: face;
}


-------------------------------------- Expressions -----------------------------------

Sequence Control Structure : 
A sequence of expression is also an expression, with the evaluation value of the last
expr in sequence.

i.e.  expr1; expr2; expr3; expr4; ... exprn;

is also an expr with value of evaluation of exprn, and yes all expr are evaluated in order



Conditinal Control Structure :
if expr1 then expr2 else expr3 , evaluates to expr2 if expr1 is true, otherwise expr3


Parenthesized (grouping) expressions (for sequence control structure) :
One can group togethr multiple expression (like the sequence control structure) with value being last of all expressions
using two ways ===> parentheses/begin end
i.e.
     let expr =  ( expr1; expr2; expr3; expr4; ... exprn )
OR
     let expr = begin expr1; expr2; expr3; expr4; ... exprn end


let binding is also an expression.
let binding is defined as let pattern = expr;;, this whole line is an expr,
so you can do:
let a =4 in
    let b = 5 in
    	let c = 2 in
	    a * b * c;;


Function definition is an expression :
e.g.
function x -> x * x;; is an expression
so you can do

let sq = function x -> x * x;;

bcoz let binding is nothing but let pattern = expr;;
Similarly function with multiple cases of pattern matchin is an expr



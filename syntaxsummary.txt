
Note: YOU CANNOT COMPARE FUNCTIONS IN ML, even thought they are first
class values.

Essential sublanguage of Ocaml (Everything is an expression):

expr ::= | c 	      	       // constant
     	 | (op)		       // parenthesized expression
	 | x		       // named object
	 | (e1, e2, .. en)	// tuples
     	 | C e
	 | e1 e2 e3 .. en	// function application
	 | fun x -> e		// lambdas or func definition(mul arg)
	 | function pi -> ei    // lambdas or function definition
	 | let x = e1 in e2	// let expressions
	 | match e0 with pi -> ei // match expressions
	 | if e1 then e2 else e3 // conditional expression
	 | while e1 do e2 done	 // conditional expression
	 | e1 :: e2    	  	 // lists
	 | Constr e1		 // custom type vales
	 | (e1: t1)		// parenthesized expression with type constraint
	 | begin e1 end		// parenthesized expression
	 | e1 infix-op e2
	 
Expressions evaluate to values in a dynamic environment,
one enriched by name value bindings.
Values are syntactic subset of expressions :

v ::= c | (op) | (v1, v2, v3 ... vn)
      | C v
      | fun x -> e // lambdas(abstractions) are function values

Time travel and function closures :
A function value is really a data struct
that has two parts:
1. The code (obviously)
2. the environment that was current when function was
   defined(lexical scope). Which gives meaning to all the free
   variables of the function body.

A function application :
- evaluates the code part of the closure
- in  the environ ment part of closure(which is relevant if free variables are present)
- extended to bind the function argument

With lexical scoping, well-typed programs are
guaranteed never to have any variables in the code
body other than function argument and variables bound by
closure environment

Recursion with auxillary functions:
sometimes we might need to use auxillary functions that hold
extra argument(which is initially empty) carrying state
of currently constructed answer structure
from matching on original input data structure,
the trick is to return the constructed structure at base case.

i.e. until the base case hits, the modified structure is present in
argument, on hitting base case,the modified strucuture is in
return value of function

global let delcarations :
let abc = 1;

local let declaratiosn :
let abc = 1 in expr;

moral of story : all functions have single argument

ways to declare a function :

1) lambda way : function x -> x * x;
   lambda way with multi argument : "fun" keyword should be used
   lambda way also does pattern matching by the way
   
2) multi argument let (auto curried):
let fn a b c = a+b+c
which expands as
let fn = function a -> function b -> function c -> a + b + c

converting let's to lambdas :
let succ x = x + 1;
let succ = function x -> x + 1;

converting lambdas to lets:
let succ = function x -> x * x;;
let succ x = x * x;;

imp notes :
a function value ( a closure) can be passed around as a value or returned as a result in case of higher order functions.

higher order functions :
let h = function f -> function y -> (f y) + y;;
val h : (int -> int) -> int -> int = <fun> 

Why do functional languages don't need type annotation :
they are mostly analyzed by datum they are operating on
and all code is generic <T>

Type constraint :
programmer annotating the type helps compiler syntax is like following
let add (x:int) (y:int) = x + y;;

Pattern matching :
The reason pattern matching is useful because of
structural induction on the length of terms and constructors
pattern matching applies on values(also function values - just like in lambda calculus)
lamdba style directly starts with pattern matching without letting us specify params , in match style we let specify param along with fn and also pattern match with same name( here v)

let imply v = match v with
| (true,x) -> x
| (false, x) -> true

Pattern matching should be linear, that is no variable can occur more than
once inside a pattern e.g.

(Wrong Syntax)
let equal cc = match cc with
| (x,x) -> true  // this a big NO NO
| (x,y) -> false;;
error : the variable is bound several times

Pattern matching with "function" keyword lets you pattern match on params:
function p1 -> expr1 | p2 -> expr2 |.... | pn -> exprn;

also equivalent to
function exp -> match exp with | p1 -> expr1 | p2 -> expr2 |....| pn -> exprn 


Total functions and partial functions in case functions
defined using pattern matching
e.g.
let (doubler: int -> int) = function x -> x * 2;;
is total, i.e. is defined for all ints
let pngpng = function p -> "pong"
is total, i.e. is defined fo all arguments a'

Here is a function based on pattern matching that is non-total/partial
let pnp = function "ping" -> "pong
which is defined only for input "ping"
and will give Match_failure for all other cases

"new bindings/variable declarations happen in pattern matching
in case unbound variables are encountered in pattern (which is
by the way how let declarations work it seems)"

Pattern matching can happen also without using match or function keywords,
simply using 'let' which does bindings of unbound vars in pattern side of let
binding (usually useful for single case pattern matchings)
e.g. let (x,y) = 2,3;; // binds x to 2, and y to 3
let head :: 2 :: _ = [1;2;3];; // binds head to 1


Naming a value being matched using "as" (Good style) :
During pattern matching, it is sometimes useful to name
part or all of pattern. (Also helps avoid reconstruction sometimes)
"as" keyword in pattern matching, is greedy and takes as many terms to left
as possible unless you put a bracket.
Let's say we have :
# let rec compress = function
  | a :: (b :: _ as t) -> if a = b then compress t else a :: compress t
  | smaller -> smaller;;

One would have thought t is bound to _ but instead,
Here t is bound to b :: _

here is another example of comparing rationals:
let min_rat pr = match pr with
| ((_,0), p2) -> p2
| (p1, (_,0)) -> p1
| (((n1, d1) as r1),((n2, d2) as r2)) ->
    if (n1 * d2) < (n2 * d1) then r1 else r2;;


Evaluation order in chained let constructs :
e.g.
 let x = 1 in let y = x+2 in let z = y+3 in z;;

Note that here the order of evaluation is also left-to-right.
(It is always left-to-right in every chain of let constructs.)

Scoping in let expressions :
OCaml scoping rules are the usual ones, i.e., names refer to the nearest (innermost) definition. In the expression:

let v = e1 in e2

The variable v isn't visible (i.e., cannot be named) in e1. If (by chance) a variable of that name appears in e1, it must refer to some outer definition of (a different) v

Must do ex 3.2 in jason hickey's textbook as practice


 No, no overloading. 
 Overloading in languages with Hindley-Milner type system is problematic since it makes type inference undecidable.

Type information is not preserved at runtime, so you can't match on types or do things like that.

----------  Types and pattern matchin -------------------------
product types : tuples(unnamed components) and records(named components)
Sum types: Variants(qualified unions and enum)

Declaring new types :
type keyword is used
type name is always starts with lowercase letter
type constructor is always Uppercase letter followed by "of" followed by arguments
type constructor that does not need any argument is also known as a constant constructor
and can be directly treated as values

list of a single type:
type pincodes = int list;;
type guests = int string;;

unnamed tuples/regular tuples :
type myType = int * string;;
type point3d = float * float * float;;

tuple/record(named tuples) types(product types) :
(Note: field names should be lower case)
type personalName = {
     name: string;
     initial: string option;
     lastName: string;
}

Note: In Ocaml, order of named tuples does not matter,
i.e. {name: "hi"; initial: "K"; lastName: "Doe"}
is same as
{ initial: "K"; name: "hi"; lastName: "Doe"}
or same as
{ lastname: "Doe"; initial: "K"; name: "hi" }

variant(Sum) types:
e.g.
type suit = Spades | Hearts | Diamonds | Clubs;; constant constructors/enums
type card =
| King of suit
| Queen of suit
| Knave of suit
| Minor_card of suit * int
| Trump of int
| Joker;;

Type constructors are useful in pattern matching :
people usually write an accompanying
tostring function for declared types like this(like for java POJOs)


let string_of_suit = function
| Spades -> "spades"
| Hearts -> "hearts"
| Diamonds -> "diamonds"
| Clubs -> "clubs"

You will often see recursive variants used for defining recursive data types
like trees etc :
type binary_tree =
 | Leaf of int
 | Tree of binary_tree * binary_tree


Since sum types and product types are algebraic data types
you can arbitrarily combine them to make new types
e.g.
1) sum of product of type
type foo =
| Nothing
| Pair of int * int
| Info of String * String

2)sum of sum of types
type Meeting = Hello | Hi
type Parting = Bye | GoodBye

type Greeting = Meeting | Greeting

3) product of product of types
//t1 = string * string option  * string
type personalName = {
     firstName : string;
     middleInitial : string option;
     lastName : string;
}
// t2 = string option * string * string * string
type addressInfo = {
     address : string option;
     state : string;
     city : string;
     zip : string;
}
// t3 = t1 * t2
type contactInfo = {
     perosnalName : personalName;
     adress: addressInfo;
}

4) product of sum of types
type suit = Clubs | Diamonds | Hearts | Spade
type face = One | Two | Three | ... | Jack | Queen | King | Ace
type cardPlayed = {
     suit: suit;
     face: face;
}

* Writing good toString functions for algebraic data types:

1. for variant/tagged union/discriminated unions/sum types, use pattern matching to write a
good toString function

e.g.
type animal = Cat of int
     	    | Dog of int
	    | Bear of String
	    | Fish

let animalPrinter (ani: animal) = match ani with
    		      	| Cat cn -> "Animal is a cat with num : " ^ (string_of_int cn)
			| Dog dn -> "Animal is a dog with nuum : " ^ (string_of_int dn)
			| Bear st -> "Animal is a bear with st : " ^ st
			| Fish -> "Animal is a fish with no other arg"

(* ^ is ocaml's way of joining strings together *)

2. for record/tuple pattern matching the pattern should look like a record/tuple
e.g/
# type state = {
     lcd: int; (* last computation done *)
     vpr: int; (* value printed on screen *)
  }

# let statePrinter (stt: state) = match stt with
    		       	      | { lcd = a; vpr = d; } -> "Found lcd with " ^ (string_of_int a) ^ " Found vpr with " ^ (string_of_int d)

# let sti = { lcd = 4; vpr = 0; };;

# statePrinter sti;;




---- Subtyping and inclusion polymorphism in Ocaml(More in Ora book --
Subtyping makes it possible for an object of some type to be
considered and used as an object of other type.
Subtyping relation is only meaningful between objects,
it can only be expressed between objects.

Also unlike mainstream oo languages such as C++, Java, SmallTalk
subtyping and inheritance are different concepts in Ocaml.



-------------------------------------- Expressions -----------------------------------

Sequence Control Structure : 
A sequence of expression is also an expression, with the evaluation value of the last
expr in sequence.

i.e.  expr1; expr2; expr3; expr4; ... exprn;

is also an expr with value of evaluation of exprn, and yes all expr are evaluated in order



Conditinal Control Structure :
if expr1 then expr2 else expr3 , evaluates to expr2 if expr1 is true, otherwise expr3


Parenthesized (grouping) expressions (for sequence control structure) :
One can group togethr multiple expression (like the sequence control structure) with value being last of all expressions
using two ways ===> parentheses/begin end
i.e.
     let expr =  ( expr1; expr2; expr3; expr4; ... exprn )
OR
     let expr = begin expr1; expr2; expr3; expr4; ... exprn end


let binding is also an expression.
let binding is defined as let pattern = expr;;, this whole line is an expr,
so you can do:
let a =4 in
    let b = 5 in
    	let c = 2 in
	    a * b * c;;


Function definition is an expression :
e.g.
function x -> x * x;; is an expression
so you can do

let sq = function x -> x * x;;

bcoz let binding is nothing but let pattern = expr;;
Similarly function with multiple cases of pattern matchin is an expr


-------------Ocaml structures and modules ---------------
Module : ?

Structure : Structure packages together related definitions 
into a namespace.
(e.g.
definitions of data type and associated operations over 
that type e.g. stack, queue etc). and it is introduced by
syntax : 

module ModuleName [:t] = 
struct
  definitions 
end

Signature : Signature are interfaces for structures.
A signature specifies which components of structure are 
accessible from outside(can hide some) and with which type.
syntax :

module type SignatureName = sig 
  type specifications 
end

Modules and files :
.ml and .mli files are automatically wrapped in 
struct and sig respectively e.g.
If myfile.ml has contents DM  [and myfile.mli has contents DS]
then OCaml compiler behaves essentially as though: 

module Myfile [: sig DS end] = 
struct
  DM
end

Note:  no struct or sig keywords, no naming of module or module type 
Note:  comments to client in .mli
, comments to implementers in .ml



---------------Understanding let in terms of scheme-------------
1.) let without "in"
e.g.
let x = 1;;
let y = 2;;
let z = x + y;;

These are global binding of general form let identifier = expr

2.) let with "in" or let with a body,
These let expressions are of the general form:
----> let id = exp1 in exp2
----> let id = bound-term-expr in body-expr
Hete exp1 is called let-bound term & Here exp2 is called the body of let expression
. and id=exp1 is only valid within exp2 i.e. the body.

Binding is static(lexical) meaning that value is determined by nearest enclosing definition in program text.

Evaluation rules: let-bound term i.e. expr1(let-bound-term) is always evaluated first and its value is bound to id before going into evaluating expr2(let-body)

Shadowing: newest lexical definition is available:
e.g. try following out

#let x = 7 in
 let y =
     let x = 2 in
     	 x + 1 // 2 is shadowing 7
 in
 x + y;;// 7 in effect.

will give you 10

Another example:
let x = 1;; // global id x
// 1
let z = // glbal id z
    let x = x + x in
    let x = x + x in // sequential binding like let*
    	x + x;;
// z= 8

x;;
// 1

--------------------lambdas in Ocaml------------------------
functions are first class values in functional programming language
meaning they/lambdas can be given a name.

e.g. let increment = function i -> i + 1;;

for which the scheme equivalent would have been
(define increment (lambda (x) (+ 1 x)))

There is sugar for defining functions without using lambda everytime:
e.g.
let increment i = i + 1;;

for which scheme equivalent would have been
(define (increment x) (+ 1 x))

Function application: Function application is so universal in fp langs
that instead of using syntax like f(x) the syntax for function application
is just a 'space' so it is "f x" in Ocaml.

-----------------------Multi argument functions ---------------------

Single argument functions are simple. You just give them the argument
and they rewrite the term that is the body, evaluate it and return the
value.

The way multi argument functions are designed is that given a single
argument, they return a functioon that takes rest of arguments until
all arguments are given at which point the body-expression is
evaluated and returned.

There are many ways to write this:
1.) lambda form
# let sum = fun i j -> i + j;;
val sum : int -> int -> int // this type expr associates to right. 

Note: this is same as :
# let sum = (fun i -> (fun j -> i + j));;
So all multi argument functions can be converted into single arg functions

2.) sugared let form
# let sum i j = i + j;;

Another useful use of multi argument functions is partial application
e.g.
let incr = sum 1;;
// since sum with incomplete numkber of arguments returns a function,
// to which we gave the name increment!

Things to remember:
** functions can be arbitrarily nested.
** functions can be passed as arguments to other functions
For higher order functions that take functions as arguments
you'll notice explicit parentheses in higher order fn type definition
** functions can be returned from functions.

----------------Scoping rules of functions ----------------------

Static binding/lexical scoping:
To drive the point home :
The value of a variable is determined by code in which a function
is defined -- not by the code in which a function is evaluated.

If function has free variables when defined, it encloses
text environment during the time of definition.

Here is a concrete example:

let i = 5;;
let addi j = i + j;; // is a free variable and is enclosed with 5.
let i = 7;; we shadowed i's value
addi 3;;// value used is the one enclosed when addi was defined i.e 5
-: val = 8

----------------------Labeled parameters and arguments------------
One often gets confused between parameters and arguments.
One good way to remember is Klingon Style taken from sjbaker's site:
Klingon function calls do not have parameters, they have arguments
and they always WIN THEM.

So function calls have arguments.
& function definitions have formal parameters.

Ocaml allows functions to have labeled and optional parameters.

Labeled parameters are specified with syntax ~label: pattern.
Labeled argumets have similar syntax ~label: expression.

e.g.
# let f ~x:i ~y:j = i - j;; //x and y are labels, i & j are labeled parameters
val f: x:int -> y:int -> int = <fun>


// labeled arguments passed to function f
# f ~y:1 ~x:2 ;;
-: int = 1

// NOte: order does not matter in case of labeled arguments
// passing a single labeled argument
# f ~y:1;;
-: x:int -> int = <fun>

** Many a times you would want to be label names same as parameter
names when defining a function, so there is a ocaml shorthand ~label

e.g.
# let f ~x ~y = x - y;;

** similarly argument ~label represents both the label and argument

e.g.
# let y = 1 in
  let x = 2 in
      f ~y ~x;;


Optional parameters can be specified with ?
e.g.
# let g ?(x = 1) y = x - y;;
val g: ?x:int -> int = <fun>

arguments:
# g 1;; // y is interpreted as 1

# g ~x:3 4;; // to use optional argument, it should always be labeled.

Rules of thumb to follow for optional and labeled arguments:
* optional parameter should always be followed by non optional parameter. This makes definition unambiguous to the compiler.
This is because it isn't possible to know when an optional
argument has been omitted.
Try out plyaing wiht
# let f ~x ?(y = 1) = x - y;;



* order of labeled args does not matter, except when label occurs more than once(wtf?)
# let h ~x:i ~x:j ?(y = 1) ~z =
   i*1000 + j*100 + y*10 + z;;

# h ~z:3 ~x:4 ~y:5 ~x:6;;
  int = 4653

* Labeled and optional arguments should be specified explicitly for
higher order functions.
Always annotate types of input/output functions in higher order fns
e.g.
# let apply (g: ?x:int -> int -> int) = g ~x:1 2 + 3;;

---------------------Pattern matching semantics----------------------------

match exp0 with
  | pat1 -> expr1
  | pat2 -> expr2
  | pat3 -> expr3

Operational semantics:
            First always exp0 is evaluated, then it is matched top to bottom,
            left to right with patterns. A pattern is an expression made of
            constants and variables. When matching against a constant, same
            constant should be found on the other side else mathching fails
            and variable pattern matching always succeeds with accompanying
            binding.
            Suppose pati matches, only then expri is evaluated and rewritten
            as result of whole match expression.

Pattern matching in functions :
Ocaml provides the keyword function (instead of fun) for single argument pattern
matching.
e.g.
let rec fib = function
 | 0 -> 0
 | 1 -> 1
 | i -> fib (i-1) + fib(i-2)

PAtterns are everywhere :
let pattern = expression
let identifier pattern patttern ... pattern = expression
fun pattern -> expression
function pattern -> expression

Note: pattern matching cannot have function values:
e.g. following throws error:
match (fun i -> i + 1) with
  (fun i -> i + 1) -> true;;

Patterns primarily are made of combination of constants, variables and costructors

-----------------------------type systems and schemes---------------------
lets consider a function like : fn x => x;
How polymorphic is it in terms of types? very!
this identity function has infinitely many types e.g. int -> int, string -> string, float -> float ... etc
i.e. one for each choice of type parameter
There is a pattern here: which is captured by notion of a type scheme.
A type scheme is a type expression involving one or more type variables
A type variable stands for an unknown but arbitrary type expression.
Type variables are written 'a (alpha), 'b (beta), 'c (gamma)

E.g. type scheme: 'a -> 'a
has instances int->int, string->string, (int*int)->(int*int)
But it does not have instances int->string,

However type scheme: 'a -> 'b
has both possible instances string -> string and int -> string

Type schemes are used to express polymorphic behaviour of functions.
e.g. fn (x,y) => x
will have type scheme 'a -> 'b -> 'a

It is remarkable in ML that every expression has a principal type scheme.
That there is almost always a best or most general way to infer
types for expressions that maximises generality and hence flexibility.

How is this achieved ?
Type inference is a process of constraint satisfaction.
First the expression determines a set of equations governing
relationships among types of its subexpressions.

Constraint generation: if function is applied to an argument,
then a constraint equating the domain type of function with type
of argument is generated.

This constraint satisfaction is also known as unification, and
solved using a process similar to gaussian elimination.

Solution of 3 types:
1. overconstrained : no solution, type error.
2. underconstrained: many solutions, ambiguous(overloading) or polymorphic
3. uniquely determined: prcisely one solution



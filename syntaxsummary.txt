
Essential sublanguage of Ocaml (Everything is an expression):

expr ::= | c 	      	       // constant
     	 | (op)		       // parenthesized expression
	 | x		       // named object
	 | (e1, e2, .. en)	// tuples
     	 | C e
	 | e1 e2 e3 .. en	// function application
	 | fun x -> e		// lambdas or func definition(mul arg)
	 | function pi -> ei    // lambdas or function definition
	 | let x = e1 in e2	// let expressions
	 | match e0 with pi -> ei // match expressions
	 | if e1 then e2 else e3 // conditional expression
	 | while e1 do e2 done	 // conditional expression
	 | e1 :: e2    	  	 // lists
	 | Constr e1		 // custom type vales
	 | (e1: t1)		// parenthesized expression with type constraint
	 | begin e1 end		// parenthesized expression
	 | e1 infix-op e2
	 
Expressions evaluate to values in a dynamic environment,
one enriched by name value bindings.
Values are syntactic subset of expressions :

v ::= c | (op) | (v1, v2, v3 ... vn)
      | C v
      | fun x -> e // lambdas(abstractions) are function values

Time travel and function closures :
A function value is really a data struct
that has two parts:
1. The code (obviously)
2. the environment that was current when function was
   defined(lexical scope). Which gives meaning to all the free
   variables of the function body.

A function application :
- evaluates the code part of the closure
- in  the environ ment part of closure(which is relevant if free variables are present)
- extended to bind the function argument

With lexical scoping, well-typed programs are
guaranteed never to have any variables in the code
body other than function argument and variables bound by
closure environment

Recursion with auxillary functions:
sometimes we might need to use auxillary functions that hold
extra argument(which is initially empty) carrying state
of currently constructed answer structure
from matching on original input data structure,
the trick is to return the constructed structure at base case.

i.e. until the base case hits, the modified structure is present in
argument, on hitting base case,the modified strucuture is in
return value of function

global let delcarations :
let abc = 1;

local let declaratiosn :
let abc = 1 in expr;

moral of story : all functions have single argument

ways to declare a function :

1) lambda way : function x -> x * x;
   lambda way with multi argument : "fun" keyword should be used
   lambda way also does pattern matching by the way
   
2) multi argument let (auto curried):
let fn a b c = a+b+c
which expands as
let fn = function a -> function b -> function c -> a + b + c

converting let's to lambdas :
let succ x = x + 1;
let succ = function x -> x + 1;

converting lambdas to lets:
let succ = function x -> x * x;;
let succ x = x * x;;

imp notes :
a function value ( a closure) can be passed around as a value or returned as a result in case of higher order functions.

higher order functions :
let h = function f -> function y -> (f y) + y;;
val h : (int -> int) -> int -> int = <fun> 

Why do functional languages don't need type annotation :
they are mostly analyzed by datum they are operating on
and all code is generic <T>

Type constraint :
programmer annotating the type helps compiler syntax is like following
let add (x:int) (y:int) = x + y;;

Pattern matching :
The reason pattern matching is useful because of
structural induction on the length of terms and constructors
pattern matching applies on values(also function values - just like in lambda calculus)
lamdba style directly starts with pattern matching without letting us specify params , in match style we let specify param along with fn and also pattern match with same name( here v)

let imply v = match v with
| (true,x) -> x
| (false, x) -> true

Pattern matching should be linear, that is no variable can occur more than
once inside a pattern e.g.

(Wrong Syntax)
let equal cc = match cc with
| (x,x) -> true  // this a big NO NO
| (x,y) -> false;;
error : the variable is bound several times

Pattern matching with "function" keyword lets you pattern match on params:
function p1 -> expr1 | p2 -> expr2 |.... | pn -> exprn;

also equivalent to
function exp -> match exp with | p1 -> expr1 | p2 -> expr2 |....| pn -> exprn 


Total functions and partial functions in case functions
defined using pattern matching
e.g.
let (doubler: int -> int) = function x -> x * 2;;
is total, i.e. is defined for all ints
let pngpng = function p -> "pong"
is total, i.e. is defined fo all arguments a'

Here is a function based on pattern matching that is non-total/partial
let pnp = function "ping" -> "pong
which is defined only for input "ping"
and will give Match_failure for all other cases

"new bindings/variable declarations happen in pattern matching
in case unbound variables are encountered in pattern (which is
by the way how let declarations work it seems)"

Pattern matching can happen also without using match or function keywords,
simply using 'let' which does bindings of unbound vars in pattern side of let
binding (usually useful for single case pattern matchings)
e.g. let (x,y) = 2,3;; // binds x to 2, and y to 3
let head :: 2 :: _ = [1;2;3];; // binds head to 1


Naming a value being matched using "as" (Good style) :
During pattern matching, it is sometimes useful to name
part or all of pattern. (Also helps avoid reconstruction sometimes)
"as" keyword in pattern matching, is greedy and takes as many terms to left
as possible unless you put a bracket.
Let's say we have :
# let rec compress = function
  | a :: (b :: _ as t) -> if a = b then compress t else a :: compress t
  | smaller -> smaller;;

One would have thought t is bound to _ but instead,
Here t is bound to b :: _

here is another example of comparing rationals:
let min_rat pr = match pr with
| ((_,0), p2) -> p2
| (p1, (_,0)) -> p1
| (((n1, d1) as r1),((n2, d2) as r2)) ->
    if (n1 * d2) < (n2 * d1) then r1 else r2;;


Evaluation order in chained let constructs :
e.g.
 let x = 1 in let y = x+2 in let z = y+3 in z;;

Note that here the order of evaluation is also left-to-right.
(It is always left-to-right in every chain of let constructs.)

Scoping in let expressions :
OCaml scoping rules are the usual ones, i.e., names refer to the nearest (innermost) definition. In the expression:

let v = e1 in e2

The variable v isn't visible (i.e., cannot be named) in e1. If (by chance) a variable of that name appears in e1, it must refer to some outer definition of (a different) v



----------  Types and pattern matchin -------------------------
product types : tuples(unnamed components) and records(named components)
Sum types: Variants(qualified unions and enum)

Declaring new types :
type keyword is used
type name is always starts with lowercase letter
type constructor is always Uppercase letter followed by "of" followed by arguments
type constructor that does not need any argument is also known as a constant constructor
and can be directly treated as values

list of a single type:
type pincodes = int list;;
type guests = int string;;

unnamed tuples/regular tuples :
type myType = int * string;;
type point3d = float * float * float;;

tuple/record(named tuples) types(product types) :
(Note: field names should be lower case)
type personalName = {
     name: string;
     initial: string option;
     lastName: string;
}

Note: In Ocaml, order of named tuples does not matter,
i.e. {name: "hi"; initial: "K"; lastName: "Doe"}
is same as
{ initial: "K"; name: "hi"; lastName: "Doe"}
or same as
{ lastname: "Doe"; initial: "K"; name: "hi" }

variant(Sum) types:
e.g.
type suit = Spades | Hearts | Diamonds | Clubs;; constant constructors/enums
type card =
| King of suit
| Queen of suit
| Knave of suit
| Minor_card of suit * int
| Trump of int
| Joker;;

Type constructors are useful in pattern matching :
people usually write an accompanying
tostring function for declared types like this(like for java POJOs)


let string_of_suit = function
| Spades -> "spades"
| Hearts -> "hearts"
| Diamonds -> "diamonds"
| Clubs -> "clubs"

You will often see recursive variants used for defining recursive data types
like trees etc :
type binary_tree =
 | Leaf of int
 | Tree of binary_tree * binary_tree


Since sum types and product types are algebraic data types
you can arbitrarily combine them to make new types
e.g.
1) sum of product of type
type foo =
| Nothing
| Pair of int * int
| Info of String * String

2)sum of sum of types
type Meeting = Hello | Hi
type Parting = Bye | GoodBye

type Greeting = Meeting | Greeting

3) product of product of types
//t1 = string * string option  * string
type personalName = {
     firstName : string;
     middleInitial : string option;
     lastName : string;
}
// t2 = string option * string * string * string
type addressInfo = {
     address : string option;
     state : string;
     city : string;
     zip : string;
}
// t3 = t1 * t2
type contactInfo = {
     perosnalName : personalName;
     adress: addressInfo;
}

4) product of sum of types
type suit = Clubs | Diamonds | Hearts | Spade
type face = One | Two | Three | ... | Jack | Queen | King | Ace
type cardPlayed = {
     suit: suit;
     face: face;
}

* Writing good toString functions for algebraic data types:

1. for variant/tagged union/discriminated unions/sum types, use pattern matching to write a
good toString function

e.g.
type animal = Cat of int
     	    | Dog of int
	    | Bear of String
	    | Fish

let animalPrinter (ani: animal) = match ani with
    		      	| Cat cn -> "Animal is a cat with num : " ^ (string_of_int cn)
			| Dog dn -> "Animal is a dog with nuum : " ^ (string_of_int dn)
			| Bear st -> "Animal is a bear with st : " ^ st
			| Fish -> "Animal is a fish with no other arg"

(* ^ is ocaml's way of joining strings together *)

2. for record/tuple pattern matching the pattern should look like a record/tuple
e.g/
# type state = {
     lcd: int; (* last computation done *)
     vpr: int; (* value printed on screen *)
  }

# let statePrinter (stt: state) = match stt with
    		       	      | { lcd = a; vpr = d; } -> "Found lcd with " ^ (string_of_int a) ^ " Found vpr with " ^ (string_of_int d)

# let sti = { lcd = 4; vpr = 0; };;

# statePrinter sti;;




---- Subtyping and inclusion polymorphism in Ocaml(More in Ora book --
Subtyping makes it possible for an object of some type to be
considered and used as an object of other type.
Subtyping relation is only meaningful between objects,
it can only be expressed between objects.

Also unlike mainstream oo languages such as C++, Java, SmallTalk
subtyping and inheritance are different concepts in Ocaml.



-------------------------------------- Expressions -----------------------------------

Sequence Control Structure : 
A sequence of expression is also an expression, with the evaluation value of the last
expr in sequence.

i.e.  expr1; expr2; expr3; expr4; ... exprn;

is also an expr with value of evaluation of exprn, and yes all expr are evaluated in order



Conditinal Control Structure :
if expr1 then expr2 else expr3 , evaluates to expr2 if expr1 is true, otherwise expr3


Parenthesized (grouping) expressions (for sequence control structure) :
One can group togethr multiple expression (like the sequence control structure) with value being last of all expressions
using two ways ===> parentheses/begin end
i.e.
     let expr =  ( expr1; expr2; expr3; expr4; ... exprn )
OR
     let expr = begin expr1; expr2; expr3; expr4; ... exprn end


let binding is also an expression.
let binding is defined as let pattern = expr;;, this whole line is an expr,
so you can do:
let a =4 in
    let b = 5 in
    	let c = 2 in
	    a * b * c;;


Function definition is an expression :
e.g.
function x -> x * x;; is an expression
so you can do

let sq = function x -> x * x;;

bcoz let binding is nothing but let pattern = expr;;
Similarly function with multiple cases of pattern matchin is an expr


-------------Ocaml structures and modules ---------------
Module : ?

Structure : Structure packages together related definitions 
into a namespace.
(e.g.
definitions of data type and associated operations over 
that type e.g. stack, queue etc). and it is introduced by
syntax : 

module ModuleName [:t] = 
struct
  definitions 
end

Signature : Signature are interfaces for structures.
A signature specifies which components of structure are 
accessible from outside(can hide some) and with which type.
syntax :

module type SignatureName = sig 
  type specifications 
end

Modules and files :
.ml and .mli files are automatically wrapped in 
struct and sig respectively e.g.
If myfile.ml has contents DM  [and myfile.mli has contents DS]
then OCaml compiler behaves essentially as though: 

module Myfile [: sig DS end] = 
struct
  DM
end

Note:  no struct or sig keywords, no naming of module or module type 
Note:  comments to client in .mli
, comments to implementers in .ml

